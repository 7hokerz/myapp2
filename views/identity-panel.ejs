<input type="button" id="search" value="search">

<h2>상태</h2>
<div id="status">
    <p> 남은 페이지(포지션): 0  </p>
    <p> 현재 위치: 0    </p>
    <p> 현재 페이지: 0  </p>
</div>

<h2>고닉에 해당하는 ID</h2>
<div id="nick-count">고닉 개수: 0</div>
<div id="ids">없음</div>

<h2>DB에 저장된 고닉</h2>
<input type="button" id="delete-garbage" value="UID 유효성 검사" >
<input type="button" id="post-is-valid" value="게시글 유효성 검사" >
<table>
    <thead>
        <tr>
            <th>식별코드</th>
            <th>갤러리 명</th>
            <th>링크1 (DB)</th>
            <th>링크2 (스캔한 갤러리)</th>
        </tr>
    </thead>
    <tbody id="nicks">
    </tbody>
</table>

<script>
    class IndexPage {
        static EL_IDS = {
            GALLERY_ID: 'galleryId',
            NICKNAME: 'nickname',
            KEYWORD: 'keyword',
            UID: 'uid',
            POS: 'pos',
            LIMIT: 'limit',
            GALLERY_TYPE: 'gallery',
            IS_PROXY: 'is-proxy',
            IDS_DIV: 'ids',
            STATUS_DIV: 'status',
            NICKS_TBODY: 'nicks',
            SEARCH_BTN: 'search',
            STOP_BTN: 'stop',
            MODE_SELECT: 'mode',
            TYPE_SELECT: 'search-type',
            UNIT_TYPE_SELECT: 'unit-type',
            DELETE_GARBAGE_BTN: 'delete-garbage',
            SAVE_OPTIONS_BTN: 'save-options',
            NICK_COUNT_SPAN: 'nick-count'
        };
        static API_PATHS = {
            CLIENT_INPUT: '/api/client-input', 
            USER_COLLECT: '/api/user/collect',
            USER_STOP: '/api/user/stop', 
        };

        constructor() {
            this._bindElements();
            this._init();
            this._addEventListeners();
        }
        
        _init() {
            this._loadOptionsFromSessionStorage();
            this._setInputStatus(false); 
            this.eventSource = null; 
            this.nickCount = 0;
        }

        _bindElements() { // 요소 바인딩
            // Input elements
            this.galleryIdInput = document.getElementById(IndexPage.EL_IDS.GALLERY_ID);
            this.nicknameInput = document.getElementById(IndexPage.EL_IDS.NICKNAME);
            this.keywordInput = document.getElementById(IndexPage.EL_IDS.KEYWORD);
            this.uidInput = document.getElementById(IndexPage.EL_IDS.UID);
            this.posInput = document.getElementById(IndexPage.EL_IDS.POS);
            this.limitInput = document.getElementById(IndexPage.EL_IDS.LIMIT);

            // Output/Status elements
            this.idsDiv = document.getElementById(IndexPage.EL_IDS.IDS_DIV);
            this.statusDiv = document.getElementById(IndexPage.EL_IDS.STATUS_DIV);
            this.nicksTbody = document.getElementById(IndexPage.EL_IDS.NICKS_TBODY);
            this.nickCountSpan = document.getElementById(IndexPage.EL_IDS.NICK_COUNT_SPAN);

            // Buttons and Selects
            this.isProxyCheckbox = document.getElementById(IndexPage.EL_IDS.IS_PROXY);
            this.galleryTypeSelect = document.getElementById(IndexPage.EL_IDS.GALLERY_TYPE);
            this.modeSelect = document.getElementById(IndexPage.EL_IDS.MODE_SELECT);
            this.typeSelect = document.getElementById(IndexPage.EL_IDS.TYPE_SELECT);
            this.unitTypeSelect = document.getElementById(IndexPage.EL_IDS.UNIT_TYPE_SELECT);
            this.actionTypeSelect = document.getElementById('action-type');
            this.searchBtn = document.getElementById(IndexPage.EL_IDS.SEARCH_BTN);
            this.stopBtn = document.getElementById(IndexPage.EL_IDS.STOP_BTN);
            this.deleteGarbageBtn = document.getElementById(IndexPage.EL_IDS.DELETE_GARBAGE_BTN);
            this.saveOptionsBtn = document.getElementById(IndexPage.EL_IDS.SAVE_OPTIONS_BTN);
            this.deletePostIsValidBtn = document.getElementById('post-is-valid');
        }
        
        _getValueFromUsers() {
            this.GID = this.galleryIdInput.value.trim() || null;
            this.nickname = this.nicknameInput.value.trim() || null;
            this.keyword = this.keywordInput.value.trim() || null;
            this.UID = this.uidInput.value.trim() || null;
            this.pos = parseInt(this.posInput.value.trim(), 10) || 0;
            this.limit = parseInt(this.limitInput.value.trim(), 10) || 1;
            this.isProxy = this.isProxyCheckbox.checked;

            if (isNaN(this.pos)) this.pos = 0;
            if (isNaN(this.limit) || this.limit <= 0) this.limit = 1;

            return {
                GID: this.GID,
                nickname: this.nickname,
                keyword: this.keyword,
                UID: this.UID,
                pos: this.pos,
                limit: this.limit,
                isProxy: this.isProxy,
                galleryType: this.galleryTypeSelect.value,
                mode: this.modeSelect.value,
                type: this.typeSelect.value,
                unitType: this.unitTypeSelect.value,
                actionType: this.actionTypeSelect.value,
            };
        }
        
        _setInputStatus(isSearching) {
            this.galleryTypeSelect.disabled = isSearching;
            this.modeSelect.disabled = isSearching;
            this.typeSelect.disabled = isSearching;
            this.unitTypeSelect.disabled = isSearching;
            this.actionTypeSelect.disabled = isSearching;
            this.searchBtn.disabled = isSearching;
            this.stopBtn.disabled = !isSearching;
            this.deleteGarbageBtn.disabled = isSearching;
        }

        _addEventListeners() {
            this.modeSelect.addEventListener('change', () => this._updateUrlAndReload());
            this.typeSelect.addEventListener('change', () => this._updateUrlAndReload());

            this.searchBtn.addEventListener('click', () => this.searchAccountFromSite());
            this.stopBtn.addEventListener('click', () => this.stopSearch());
            this.deleteGarbageBtn.addEventListener('click', () => this.clearDeleted());
            this.saveOptionsBtn.addEventListener('click', () => this._saveOptionsToSessionStorage());
            this.deletePostIsValidBtn.addEventListener('click', () => this.chkPostIsValid());
        }

        _updateUrlAndReload() {
            const url = new URL(window.location.href);
            url.searchParams.set('mode', this.modeSelect.value);
            url.searchParams.set('type', this.typeSelect.value);
            location.href = url.toString();
        }

        _updateStatus(message, append = false) {
            if (append) {
                this.statusDiv.innerHTML += message;
            } else {
                this.statusDiv.innerHTML = message;
            }
        }

        _saveOptionsToSessionStorage() {
            const values = this._getValueFromUsers();
            sessionStorage.setItem('inputs', JSON.stringify({
                GID: values.GID,
                nickname: values.nickname,
                keyword: values.keyword,
                UID: values.UID,
                pos: values.pos,
                limit: values.limit,
                galleryType: values.galleryType,
                unitType: values.unitType,
                actionType: values.actionType,
                isProxy: values.isProxy,
            }));
            console.log('Options saved to sessionStorage');
        }
        
        _loadOptionsFromSessionStorage() {
            document.addEventListener('DOMContentLoaded', () => {
                const savedValue = JSON.parse(sessionStorage.getItem('inputs'));
                
                this.galleryIdInput.value = savedValue.GID || '';
                this.nicknameInput.value = savedValue.nickname || '';
                this.keywordInput.value = savedValue.keyword || '';
                this.uidInput.value = savedValue.UID || '';
                this.posInput.value = savedValue.pos || 0;
                this.limitInput.value = savedValue.limit || 1;
                this.galleryTypeSelect.value = savedValue.galleryType || '';
                this.unitTypeSelect.value = savedValue.unitType || 'page';
                this.actionTypeSelect.value = savedValue.actionType || 'insert';
                this.isProxyCheckbox.checked = savedValue.isProxy || false;
                console.log('Options loaded from sessionStorage');
                
            });
        }

        async searchAccountFromSite() {
            const values = this._getValueFromUsers();

            if(!(this.GID && this.limit <= 1000)) {
                alert('유효한 값을 입력하세요.');
                return;
            }
            console.log('게시글의 고닉 조회');

            this._setInputStatus(true);
            this.idsDiv.innerHTML = '';
            this.nicksTbody.innerHTML = '';
            this.nickCount = 0; // Reset count
            if(this.nickCountSpan) this.nickCountSpan.textContent = `고닉 개수: ${this.nickCount}`;

            try {
                const response = await fetch(IndexPage.API_PATHS.CLIENT_INPUT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(values)
                });

                if (!response.ok) {
                    // Try to get error message from backend if possible
                    let errorMsg = `서버 통신 오류 (${response.status}).`;
                    try {
                        const errorData = await response.json();
                        errorMsg += ` 메시지: ${errorData.message || response.statusText}`;
                    } catch (e) { /* Ignore if response body is not JSON */ }
                    throw new Error(errorMsg);
                }

                // 2. Setup SSE listener
                this._setupSSEListener();

            } catch (error) {
                console.error('Search initiation failed:', error);
                this._updateStatus(`<p style="color: red;">오류 발생: ${error.message}</p>`, true);
                this._setInputStatus(false);
            }
        }
        
        _setupSSEListener() {
            if (this.eventSource) {
                this.eventSource.close();
            }

            this.eventSource = new EventSource(IndexPage.API_PATHS.USER_COLLECT);

            this.eventSource.addEventListener('status', (event) => {
                try {
                    const data = JSON.parse(event.data);
                    this._updateStatus(`
                        <p> 남은 페이지(포지션): ${data.restPage ?? 'N/A'} </p>
                        <p> 현재 위치: ${data.position ?? 'N/A'} </p>
                        <p> 현재 페이지: ${data.curPage ?? 'N/A'} </p>
                    `);
                } catch (e) {
                    console.error("Error parsing status event data:", e, event.data);
                }
            });

            this.eventSource.addEventListener('fixed-nick', (event) => {
                try {
                    const newIdentityCodes = JSON.parse(event.data);
                    if (!Array.isArray(newIdentityCodes)) {
                        console.error("Invalid data format for fixed-nick:", newIdentityCodes);
                        return;
                    }

                    const fragment = document.createDocumentFragment();
                    newIdentityCodes.forEach(id => {
                        if (Array.isArray(id) && id.length >= 2) {
                            const span = document.createElement('span');
                            span.innerHTML = `<b><a href='https://gallog.dcinside.com/${encodeURIComponent(id[0])}' target="_blank">${id[0]}</a>(${id[1]})</b> `;
                            fragment.appendChild(span);
                            this.nickCount++;
                        } else {
                            console.warn("Skipping invalid identity code entry:", id);
                        }
                    });
                    this.idsDiv.appendChild(fragment);
                    if(this.nickCountSpan) this.nickCountSpan.textContent = `고닉 개수: ${this.nickCount}`;
                } catch (e) {
                    console.error("Error parsing fixed-nick event data:", e, event.data);
                }
            });

            this.eventSource.addEventListener('compare', (event) => {
                try {
                    const results = JSON.parse(event.data);

                    results.forEach((result) => {
                        this.nicksTbody.innerHTML += `<tr>
                            <td>${result.uid}</td>
                            <td>${result.GID}</td>
                            <td>
                                <a href='https://gall.dcinside.com/board/view/?id=${result.GID}&no=${result.postNum}' target="_blank">
                                    ${result.postNum}
                                </a>
                            </td>
                            <td>
                                <a href='https://gall.dcinside.com/${this.galleryTypeSelect.value}board/view/?id=${this.GID}&no=${result.no}' target="_blank">
                                    ${result.no}
                                </a>
                            </td>
                        </tr>`;
                    });

                } catch (error) {
                    
                }
            });

            this.eventSource.addEventListener('complete', (event) => {
                console.log('SSE stream complete.');
                this._updateStatus(`<p> 작업 완료 (${this.nickCount}개 발견). </p>`, true);
                this._closeSSEConnection();
                this._setInputStatus(false);
            });

            this.eventSource.onerror = (error) => {
                console.error('EventSource error:', error);
                this._updateStatus(`<p style="color: red;"> 데이터 수신 중 오류 발생. </p>`, true);
                this._closeSSEConnection();
                this._setInputStatus(false);
            };
        }

        _closeSSEConnection() {
            if (this.eventSource) {
                this.eventSource.close();
                this.eventSource = null;
                console.log('EventSource connection closed.');
            }
        }

        async stopSearch() {
            console.log('Stopping search...');
            this._updateStatus('<p> 중지 요청 중... </p>', true);
            this.stopBtn.disabled = true;

            try {
                const mode = this.modeSelect.value;
                const response = await fetch(`${IndexPage.API_PATHS.USER_STOP}?mode=${mode}`);
                if (!response.ok) {
                    throw new Error(`서버 응답 오류 (${response.status})`);
                }
                this._updateStatus('<p> 중지 요청 성공. </p>', true);
                console.log('Stop request successful.');

            } catch (error) {
                console.error('Error stopping search:', error);
                this._updateStatus(`<p style="color: red;"> 중지 요청 실패: ${error.message} </p>`, true);
            }
        }
        
        async clearDeleted() {
            const values = this._getValueFromUsers();
            if (!values.GID) {
                this._updateStatus('<p style="color: red;">갤러리 ID를 입력하세요.</p>');
                this.galleryIdInput.focus();
                return;
            }
            console.log(`Deleting garbage for gallery ID: ${values.GID}`);
            this._setInputStatus(true);
            this._updateStatus(`<p>갤러리 [${values.GID}]의 삭제된 데이터 정리 요청 중...</p>`);

            try {
                const response = await fetch(`${IndexPage.API_PATHS.NICKNAME_LIST}?galleryid=${values.GID}`, {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' }
                });

                if (!response.ok) {
                    let errorMsg = `정리 요청 실패 (${response.status}).`;
                    try {
                        const errorData = await response.json();
                        errorMsg += ` 메시지: ${errorData.message || response.statusText}`;
                    } catch (e) { /* Ignore if response body is not JSON */ }
                    throw new Error(errorMsg);
                }

                const payload = await response.json();
                console.log('Clear deleted response:', payload);
                this._updateStatus(`<p>정리 작업 완료. 결과: ${JSON.stringify(payload)}</p>`, true);

            } catch (error) {
                console.error('Error clearing deleted data:', error);
                this._updateStatus(`<p style="color: red;"> 정리 작업 실패: ${error.message} </p>`, true);
            } finally {
                this._setInputStatus(false);
            }
        }
    
        async chkPostIsValid() {
            try {
                const response = await fetch(`/api/post-list`, {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' }
                });

                if (!response.ok) {
                    let errorMsg = `검사 요청 실패 (${response.status}).`;
                    try {
                        const errorData = await response.json();
                        errorMsg += ` 메시지: ${errorData.message || response.statusText}`;
                    } catch (e) { /* Ignore if response body is not JSON */ }
                    throw new Error(errorMsg);
                }

                const payload = await response.json();
                console.log('Post validity check response:', payload);
                this._updateStatus(`<p>검사 작업 완료. 결과: ${JSON.stringify(payload)}</p>`, true);

            } catch (error) {
                console.error('Error checking post validity:', error);
                this._updateStatus(`<p style="color: red;"> 검사 작업 실패: ${error.message} </p>`, true);
            } finally {
                this._setInputStatus(false);
            }
        }
    }
    new IndexPage();
</script>
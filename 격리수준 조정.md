
병렬 실행 시 데드락이 걸리는 문제

위와 같이 `FOR UPDATE`를 적용했을 때 데이터의 정합성이 깨지지 않고 

병렬 처리를 적용하여 더욱 효율적으로 개선할 수 있다고 생각했다.

하지만 예상치 못한 문제가 있었는데 바로 `데드락`이었다.


문제가 발생하는 예시: 서로 다른 작업에서 서로의 자원이 필요한 경우

T1 시작 및 A에 대한 잠금 획득 
-> T2 시작 및 B에 대한 잠금 획득 
-> T1 이 B(또는 B의 일부)에 대해 잠금을 획득하려고 함. 대기
-> T2 가 A(또는 A의 일부)에 대해 잠금을 획득하려고 함. 대기

이처럼 서로의 잠금이 풀리길 기다리며 대기하게 된다.


위 코드에서 발생한 이유?

병렬 처리를 진행할 때 동시에 실행된 작업의 개수가 많으면 비슷한 데이터를 이용할 확률이 많아지는데

따라서 서로의 데이터가 필요한 경우가 발생할 확률 또한 높아지기 때문이다.

즉, `넥스트 키 락`으로 인한 문제임.



생각한 방법 1: 비관적 락을 유지한 채 격리수준을 조정하기

MySQL innodb 엔진의 트랜잭션 기본 격리 수준은 `Repeatable Read`

`Read Committed` 로 변경해보려고 함.


격리 수준을 조정해도 문제가 없는지?


예상 추론

1. 데드락이 해결되는가?

`repeatable read` 수준에서는 명시적 락을 사용하면 `넥스트 키 락`을 사용하고,
`read committed` 수준에서는 명시적 락을 사용하면 `레코드 락`만 사용한다. (특정 경우는 제외)

내 코드의 로직은 범위 연산이 아닌 특정 레코드에 대해서 조회를 실시하므로

필요하지 않은 갭 락이 사라져서 데드락이 거의 발생하지 않을 것으로 예상됨.


이상 현상에 대해 문제가 없는가?

2. 반복 불가능한 읽기 현상 - 

현재 비관적 락을 사용하고 있으므로 특정 레코드에 대해 잠금을 획득하면 다른 트랜잭션에서는 접근하지 못함.

따라서 반복 불가능한 읽기 현상은 나타나지 않음(UPDATE를 하지 못하기 때문에)


3. 팬텀 리드 현상 - 

명시적 락은 언두 로그에는 잠금을 걸 수 없다.
(즉 다른 트랜잭션이 데이터를 삽입하고 커밋하기 전까지는 언두 로그에 데이터 변경 사항이 저장되는데
이를 막을 수 없다는 뜻이다)

원래라면 넥스트 키 락으로 이를 방지했겠지만 현재 `read committed` 격리 수준이므로

넥스트 키 락은 사용할 수 없다.

따라서 팬텀 리드 현상은 발생할 수 있음.


그 외 문제는 없는가?

4. 테이블에 관련 행이 아무것도 없을 때

테이블: []

[23, 24, 25] 동시 삽입 시도

만족하는 레코드가 없기 때문에 잠금 획득 없이 작업이 진행된다

따라서 3개 모두 삽입될 것인데, 이는 2개만 존재해야하는 규칙을 위반한 것이 됨.



내 코드 로직을 다시 한 번 살펴보면,

`SELECT...FOR UPDATE` 조회
-> `INSERT(or UPDATE)...` 변경

조회 및 변경 작업이 트랜잭션 당 각각 1번 씩 주어진다.

우선 위 쿼리 외에 다른 쿼리가 들어오는 경우는 일단 없고,

한 트랜잭션에서 조회(또는 변경) 작업이 1번만 존재하므로

팬텀 리드 현상은 무시해도 된다.


4번 문제에 관해서는 DB 작업 이전에 비즈니스 로직에서 해결해야 함.
(데이터 전처리)

예시: 같은 조건에 대해 2개의 데이터만 남기고 DB 작업을 진행하면 4번의 경우는 문제가 되지 않음.


방법 1 요약:
비관적 락 유지, 격리 수준 변경, 병렬 요청








방법 2?: 낙관적 락 사용?



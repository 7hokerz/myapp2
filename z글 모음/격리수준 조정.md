
병렬 실행 시 데드락이 걸리는 문제

위와 같이 `FOR UPDATE`를 적용했을 때 데이터의 정합성이 깨지지 않고 

병렬 처리를 적용하여 더욱 효율적으로 개선할 수 있다고 생각했다.

하지만 예상치 못한 문제가 있었는데 바로 `데드락`이었다.


문제가 발생하는 예시: 서로 다른 작업에서 서로의 자원이 필요한 경우

T1 시작 및 A에 대한 잠금 획득 
-> T2 시작 및 B에 대한 잠금 획득 
-> T1 이 B(또는 B의 일부)에 대해 잠금을 획득하려고 함. 대기
-> T2 가 A(또는 A의 일부)에 대해 잠금을 획득하려고 함. 대기

이처럼 서로의 잠금이 풀리길 기다리며 대기하게 된다.


위 코드에서 발생한 이유?

병렬 처리를 진행할 때 동시에 실행된 작업의 개수가 많으면 비슷한 데이터 또는 갭을 이용할 확률이 많아지는데

따라서 서로의 영역이 필요한 경우가 발생할 확률 또한 높아지기 때문이다.

즉, `넥스트 키 락`으로 인한 문제임.



생각한 방법 1: 명시적 락을 유지한 채 격리수준을 조정하기

`Repeatable Read` >> `Read Committed` 로 변경해보려고 함.

이유: 격리 수준 변경으로 넥스트 키 락을 사용하지 않게 되면서 갭 락으로 인한 데드락 현상을 완화할 수 있다고 생각하였음.


격리 수준을 조정해도 문제가 없을까?

예상 추론

1. 데드락이 해결되는가?

`repeatable read` 수준에서는 명시적 락을 사용하면 `넥스트 키 락`을 사용하고,
`read committed` 수준에서는 명시적 락을 사용하면 `레코드 락`만 사용한다. (특정 경우는 제외)

내 코드의 로직은 범위 연산이 아닌 특정 레코드에 대해서 조회를 실시하므로

필요하지 않은 갭 락이 사라져서 데드락이 거의 발생하지 않을 것으로 예상됨.


2. 이상 현상에 대해 문제가 없는가?

반복 불가능한 읽기 현상 - 

현재 비관적 락을 사용하고 있으므로 특정 레코드에 대해 잠금을 획득하면 다른 트랜잭션에서는 접근하지 못함.

따라서 반복 불가능한 읽기 현상은 나타나지 않음(UPDATE를 하지 못하기 때문에)


팬텀 리드 현상 - 

명시적 락은 언두 로그에는 잠금을 걸 수 없다.
(즉 다른 트랜잭션이 데이터를 삽입하고 커밋하기 전까지는 언두 로그에 데이터 변경 사항이 저장되는데
이를 막을 수 없다는 뜻이다)

원래라면 넥스트 키 락으로 이를 방지했겠지만 현재 `read committed` 격리 수준이므로

넥스트 키 락은 사용할 수 없다. 따라서 팬텀 리드 현상은 발생할 수 있음.

(하지만 내 코드는 트랜잭션[조회 > 수정/삽입] 의 로직이므로 팬텀 리드 현상은 무시할 수 있음)


3. 그 외 문제는 없는가?

테이블에 관련 행이 아무것도 없을 때


중요!

데이터가 없던 경우(즉 PK 조합의 행이 없던 경우) insert에서 데드락이 발생함.

즉 SELECT의 명시적 락은 데드락의 원인이었다.

단, 데이터가 1개만 있어도 데드락과 이상 현상은 발생하지 않았음.

원인:
데이터가 없던 경우 명시적 락을 획득하지만 이는 일반 갭 락? 이라고 하는데 다른 것과 달리
다른 트랜잭션에 대한 일반 갭 락을 막지 않는다고 한다.

따라서 처음에 같은 부분에 대한 갭 락을 획득하였으나 나중에 insert 시 서로 충돌

그러면 read committed에서는? 이때 만족하는 행이 없다면 잠금이 아예 걸리지 않는다!(갭 락 사용 X 이므로)
따라서 잠금을 걸지 않은 것과 동일한 상태가 된다.


정리

격리 수준: `REPEATABLE READ`
명시적 락: `FOR UPDATE`

문제: 특정 상황에서 데드락 발생

조회 쿼리를 만족하는 데이터가 없을 때:

일반 갭 락 획득 
- 이 갭 락은 다른 T가 같은 영역의 갭 락을 획득하는 것을 `막지 않음`.

T1이 A 갭 락을 획득하고, T2가 B 갭 락을 획득한 상황에서 A와 B의 범위가 겹칠 수 있고 

나중에 insert할 때 이 갭 락에 대해 잠금을 획득하지 못해 서로 대기하는 **순환 대기**가 발생함.


조회 쿼리를 만족하는 데이터가 있을 때:

넥스트 키 락 획득
위의 상황 처럼 잠금 영역이 겹칠 수 없으므로 문제 상황 없음.


격리 수준: `READ COMMITTED`
명시적 락: `FOR UPDATE`

문제: 무결성 깨짐

조회 쿼리를 만족하는 데이터가 없을 때:

락 획득 없음
- 명시적 락을 선언하지 않은 것과 다를 게 없음.

3개 이상의 데이터 삽입 상황 발생


조회 쿼리를 만족하는 데이터가 있을 때:

레코드 락 획득
한 행은 하나의 T만 접근하므로 문제 상황 없음.


show engine innodb status << 데드락 로그 확인

+ 넥스트 키 락 또한 갭 락을 포함하는데 이 갭 락 또한 똑같다.


추가 사항 (Read committed)
레코드 락은 말 그대로 기존의 레코드 및 인덱스에 잠금을 획득하는 것이다.
조건과는 아무 상관이 없음. (PK거나 유일하지 않는다고 가정할 때)

- where = 11 For update 존재하는 레코드에 잠금 획득
- 같은 조건 (11)에 대한 삽입 진행 (이때 막히지 않음.)

기존에 있던 행과는 별개의 것이므로.



갭 락 >> 해당 인덱스 내에 이전에 존재하지 않던 새로운 값이 특정 범위에 삽입되는 걸 방지.

현재 (10, 20, 30) 존재 >> 20 잠금 실시
갭 락은 (10(10은 포함 X) ~ 20(20 포함 X)), (20(20 포함 X) ~ 30(30 포함 X)) 에 걸림.
즉 바로 현재 행을 기준으로 바로 앞 뒤 행 직전까지의 모든 갭을 잠금

새로 20 삽입을 시도? 값만 20일 뿐 결과적으로 기존 20의 앞과 뒤 중 어느 한 곳으로 배치되는 것과 같다. 따라서 
이 또한 갭 락의 범위에 속하므로 삽입 불가

값에 대한 범위를 잠그는 게 아니다! 중요!

만약 행이 한 개 뿐이라면? 앞 뒤에 뭐가 아무것도 없으니 모든 범위에 갭 락이 걸림.



### 초기 데이터



### 테스트 코드

```javascript
    const array = [4, 6, 8, 10, ..., 100];

    const results = await Promise.allSettled(//
        array.map(async (no) => {
            await testFunction(true, 'explore4719', no, 'grsgills'); 
            await testFunction(true, 'explore7258', no + 1, 'girlsong');  
        })
    );
```

### 테스트 1: 명시적 락, Repeatable Read





### 테스트 2: 명시적 락, Read Committed




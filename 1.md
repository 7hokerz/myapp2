
명시적 락에 대하여

일반적으로 Repeatable read 수준에서는 이상현상이 발생하지 않음.
다만 읽기 작업에 한정된 이야기이고(실제로는 읽기 작업에서도 특정 케이스는 발생 가능)

트랜잭션이 읽기와 쓰기 작업이 존재하면 명시적 락이 더 좋다.

T1 읽음 -> T2 읽음 -> T1 씀 -> T2 씀(오류 위험)

기본적으로 스냅샷 기반으로 읽기를 수행하므로 락이 없으면 둘 다 읽을 수 있는데, 이때 T1이 수정한 걸 T2가 알아차리지 못해 오류가 발생할 수 있다

읽기만 한다면 문제는 없지만 쓰기를 수행하면 위와 같은 경쟁 상태가 발생할 수 있으므로 애초에 방지하는 락을 걸어주는 게 훨씬 좋다.



내가 이 주제를 다루게 된 이유?

기본적으로 잠금을 사용하지 않는 경우가 효율적이기 때문에 특별한 경우가 아닌 이상 명시적 락을 사용할 일이 없다고 생각했다.

하지만 내가 생각하지 못한 부분이 있었고 오늘 그 부분에 대해서 명확히 알게 되어 이 주제에 대해 작성한다.


MySQL의 innodb 엔진을 이용하는 환경에서 기본 트랜잭션 격리 수준은 `Repeatable Read` 이다.

여기서 우리는 2가지 방법을 생각해볼 수 있다.

1. `SELECT ... ;` (일반적인 SELECT)

이때는 잠금을 이용하지 않고 스냅샷 기반으로 조회를 시행한다. 
즉 트랜잭션이 시작될 때 테이블의 상태를 계속 유지하는 것.

2. `SELECT ... FOR UPDATE (or LOCK IN SHARE MODE);` (명시적 락 사용)

이때는 명시적 락을 사용하여 실제로 다른 트랜잭션에서 해당 데이터에 접근하지 못하게 만든다.


원래 알고 있던 케이스
T1 시작, 읽음 -> T2 시작, 읽고, 수정 및 커밋 -> T1 다시 읽음.

1의 경우: 스냅샷 기반으로 조회하므로 T2의 수정은 영향을 미치지 않음.

2의 경우: 스냅샷 기반이 아닌 최신 데이터를 조회하므로 팬텀 리드가 발생할 수 있음.
(단, innodb 엔진에서는 넥스트 키 락을 사용하여 팬텀 리드를 방지함.)


새로운 케이스
T1 시작, 읽음 -> T2 시작, 읽음 -> T1 수정 및 커밋 -> T2 다시 읽고 수정 및 커밋??

1의 경우: 명시적 락이 없으므로 T2의 접근이 허용된다. 이후 T2는 스냅샷 기반으로 다시 접근
문제점 - T2의 예상과 달리 이전에 T1이 데이터를 수정하였다. 따라서 T2가 쓰기 작업을 시행할 경우 오류가 발생할 수 있다.

2의 경우: T1이 먼저 잠금을 획득하므로 T2는 T1이 커밋할 때까지 접근하지 못함. (정합성이 보장됨.)


위 두 케이스로 크게 알 수 있던 점.

단순 읽기 작업인 트랜잭션에서는 잠금이 필요 없음. 
하지만 쓰기 작업이 포함된 경우 명시적 락을 획득하지 않으면 오류가 발생할 수 있음.
(경쟁 상태 발생으로 인한 데이터 무결성 깨짐.)



시나리오: 
초기에 postNum 컬럼에 각각 10, 20이 들어있는 레코드 존재
15와 25를 현재 레코드에서 동시에 업데이트를 시도함.


테스트 내용: 명시적 락의 유무에 따른 차이
```SQL
1. 일반 SELECT
SELECT postNum FROM ${tableName} 
WHERE identityCode = ? AND galleryCODE = ?
ORDER BY postNum ASC;

2. 명시적 락 허용
SELECT postNum FROM ${tableName} 
WHERE identityCode = ? AND galleryCODE = ?
ORDER BY postNum ASC
FOR UPDATE; 
```

테스트 코드
```javascript
    async runRaceConditionTest(testFunction) {
        const testUser = '유저';
        const testGallery = '갤러리';
        const concurrentNum1 = 15; // 초기 번호: 10, 20
        const concurrentNum2 = 25;
    
        try {
            const results = await Promise.allSettled([
                testFunction(true, testUser, concurrentNum1, testGallery), 
                testFunction(true, testUser, concurrentNum2, testGallery)
            ]);
    
            console.log('Concurrent operations finished.');
            results.forEach((result, i) => {
                if (result.status === 'rejected') {
                    console.error(`   Error: ${result.reason}`);
                }
            });
    
        } catch (error) {
            ```오류 처리```
        }
    }

    async insertPostCommentNo(mode, identityCode, postNum, galleryCODE) {
        const tableName = (mode) ? 'post_list' : 'comment_list';
    
        let connection;
        try {
            connection = await pool.getConnection();
            await connection.beginTransaction();
            const checkQuery = `...`; // 해당 갤러리 코드와 식별 코드가 일치하는 게시물 번호
    
            const [rows] = `결과 받아오기`;
    
            const isDuplicate = rows.some(row => row.postNum == postNum) // 중복 번호 검증
            await new Promise(resolve => setTimeout(resolve, 100)); // 경쟁 상태 발생을 위한 지연
            if(!isDuplicate) {
                const insertQuery = `...`; 
                
                const updateQuery = `...`;
    
                if(rows.length < 2) {
                    // 삽입
                } else {
                    // 가장 작은 번호보다 크면 업데이트
                }
            }
            await connection.commit();
        } catch (error) {
            ```오류 처리```
        } finally {
            ```커넥션 반환```
        }
    }
```

1. 명시적 락 없이 실행




실행할 때마다 결과가 다르게 나왔음. 

2. 명시적 락 적용




계속 실행해도 항상 일관된 결과를 보여줌.



따라서 명시적 락을 적용해야 확실하게 경쟁 상태가 발생하지 않는다.









병렬 실행 시 데드락이 걸리는 문제

위와 같이 FOR UPDATE를 적용했을 때 데이터의 정합성이 깨지지 않고 

병렬 처리를 적용하여 더욱 효율적으로 개선할 수 있다고 생각했다.

하지만 예상치 못한 문제가 있었는데 바로 데드락이었다.


문제가 발생하는 예시: 서로 다른 작업에서 서로의 자원이 필요한 경우

T1 시작 및 A에 대한 잠금 획득 -> T2 시작 및 B에 대한 잠금 획득 
-> T1 이 B(또는 B의 일부)에 대해 잠금을 획득하려고 함. 대기
-> T2 가 A(또는 A의 일부)에 대해 잠금을 획득하려고 함. 대기

이처럼 서로의 잠금이 풀리길 기다리며 대기하게 된다.


위 코드에서 발생한 이유?

병렬 처리를 진행할 때 작업의 개수가 많으면 비슷한 데이터를 이용할 확률이 많아지는데

위와 같이 서로의 데이터가 필요한 경우가 발생할 확률 또한 높아지기 때문이다.

















